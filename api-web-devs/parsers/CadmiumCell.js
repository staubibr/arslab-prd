'use strict';

import Core from '../tools/core.js';
import Parser from "./parser.js";

import { Simulation, TransitionsCA, TransitionCA, Options, Files } from './files.js';

import Settings from '../components/settings.js';
import Scale from '../components/scales/basic.js';
import State from '../simulation/state.js';

export default class CadmiumCell extends Parser { 
	
	Parse(files) {
		var d = Core.Defer();
		
		var cfg = files.find(function(f) { return f.name.match(/\.json/i); });
		var log = files.find(function(f) { return f.name.match(/\.txt/i); });

		if (!cfg || !log) {
			d.Reject(new Error("A config (.json) and a log (.txt) file must be provided for the Cadmium Cell-DEVS parser."));
		
			return d.promise;
		}
		
		this.time = "0";
		// this.min = Infinity;
		this.min = {};
		// this.max = -Infinity;
		this.max = {};
		
		this.Read(cfg, (content) => JSON.parse(content)).then(cfg => {
			if (!cfg) return d.Reject(new Error("Unable to parse the config (.json) file."));
			
			cfg.ports.forEach(p => {
				this.min[p.name] = Infinity;
				this.max[p.name] = -Infinity;
			});
			
			this.ReadByChunk(log, this.ParseLogChunk.bind(this, cfg)).then(log => {				
				if (!log) return d.Reject(new Error("Unable to parse the log (.log) file."));
				
				var models = [{
					name: cfg.model,
					ports : cfg.ports.map(p => ({ name: p.name, type: "output" }))
				}];
				
				var simulation = new Simulation(cfg.model, "Cadmium", "Cell-DEVS", models, cfg.size);
				var transitions = new TransitionsCA(log);
				
				var options = Settings.Default(1, cfg.ports);
				
				options.grid.styles = [];
				
				if (cfg.styles) options.grid.styles = cfg.styles;
				
				else {
					var colors = [[215,48,39],[244,109,67],[253,174,97],[254,224,144],[255,255,191],[224,243,248],[171,217,233]];

					// AUTO GENERATE STYLE. THIS WILL HAVE TO GO AWAY. WHAT IF VALUE IS NOT A NUMBER? NOMINAL CLASSES WONT WORK
					cfg.ports.forEach(p => {
						var step = (this.max[p.name] - this.min[p.name]) / colors.length;
						
						var style = colors.map((c, i) => {
							var start = this.min[p.name] + i * step;
							
							return { start:start, end:start + step, color:c }
						});
						
						options.grid.styles.push(style);
					});
					// END OF AUTO STYLE GENERATION
					
					// AUTO GENERATE STYLE. THIS WILL HAVE TO GO AWAY. WHAT IF VALUE IS NOT A NUMBER? NOMINAL CLASSES WONT WORK
					/*
					var colors = [[215,48,39],[244,109,67],[253,174,97],[254,224,144],[255,255,191],[224,243,248],[171,217,233],[116,173,209],[69,117,180]];
					var step = (this.max - this.min) / colors.length;
					
					options.grid.styles[0] = colors.map((c, i) => {
						var start = this.min + i * step;
						
						return { start:start, end:start + step, color:colors[i] }
					});
					
					options.grid.styles[0][4].end++;
					*/
					// END OF AUTO STYLE GENERATION
				}
				
				var files = new Files(simulation, transitions, null, new Options(options));
				
				d.Resolve(files);
			}, (error) => d.Reject(error));
		}, (error) => d.Reject(error));
		
		return d.promise;
	}
		
	ParseLogChunk(cfg, parsed, chunk) {		
		var start = 0;		
		
		while (start < chunk.length) {				
			var end = chunk.indexOf('\n', start);
			
			if (end == -1) end = chunk.length + 1;
			
			var line = chunk.substr(start, end - start);
			
			if (line.startsWith("[")) {
				// parse coord 
				var i = line.indexOf("(") + 1;
				var j = line.indexOf(")", i);
				var c = line.substr(i, j - i).split(',');
				
				// parse values
				var i = line.indexOf("<", j) + 1;
				var j = line.indexOf(">", i);
				var values = line.substr(i, j - i).split(',');
			
				// parse model name
				var patt = "generated by model ";
				var i = line.indexOf(patt, j) + patt.length;
				var j = line.indexOf("_(", i);
				var m = line.substr(i, j - i);
				
				for (var i = 0; i < values.length; i++) {
					var v = +values[i];
					var p = cfg.ports[i].name;
					
					if (v > this.max[p]) this.max[p] = v;
					if (v < this.min[p]) this.min[p] = v;
				
					parsed.push(new TransitionCA("Y", this.time, m, c, p, m, v));
				}
			}
			else this.time = line;
			
			var start = start + line.length + 1;
		};
		
		return parsed;
	}
}